/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Modified for SolarVerse with optimization, animation, and game logic.
*/

import * as THREE from 'three'
import React, { useRef, useMemo, useContext, createContext, useState, useEffect } from 'react'
import { useGLTF, Merged } from '@react-three/drei'
import { useFrame, ThreeEvent } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'

// Essential: Import the Zustand stores for interaction
import { useGame } from './lib/stores/useGame'
import { useAudio } from './lib/stores/useAudio'

// --- Types ---
type GLTFResult = GLTF & {
  nodes: {
    Heart: THREE.Mesh
  }
  materials: {
    Heart: THREE.MeshStandardMaterial
  }
}
type InstancesProps = {
    children: React.ReactNode;
    [key: string]: any;
}
type HeartModelProps = JSX.IntrinsicElements['group'] & { id?: string }

const context = createContext(null as any)

export function Instances({ children, ...props }: InstancesProps) {
  const { nodes } = useGLTF('/geometries/heart.gltf') as GLTFResult
  const instances = useMemo(
    () => ({
      Heart: nodes.Heart,
    }),
    [nodes]
  )
  return (
    <Merged meshes={instances} {...props}>
      {(instances: any) => <context.Provider value={instances} children={children} />}
    </Merged>
  )
}

// --- Model Component with Game Logic ---
export function Model(props: HeartModelProps) {
  const instances = useContext(context) as any
  const ref = useRef<THREE.Group>(null!)
  const [collected, setCollected] = useState(false)

  // FIX: State to store the initial Y position, safely calculated
  const [startY, setStartY] = useState(0);

  // Game State Hooks
  const { addStarToken } = useGame((state: any) => ({ addStarToken: state.addStarToken }))
  const { playSound } = useAudio((state: any) => ({ playSound: state.playSound }))

  // FIX: Use useEffect to safely determine and cache the starting Y position
  useEffect(() => {
    if (props.position) {
      const initialY = Array.isArray(props.position)
        ? props.position[1]
        : (props.position as THREE.Vector3).y || 0;
      setStartY(initialY);
    }
  }, [props.position]);


  // ADD ANIMATION: Heart rotation and bobbing
  useFrame((state, delta) => {
    if (ref.current && !collected) {
      ref.current.rotation.y += delta * 0.5
      // UPDATED: Use the cached startY instead of props.position!.y
      ref.current.position.y = startY + Math.sin(state.clock.elapsedTime) * 0.2
    }
  })

  // ADD INTERACTION: Click handler
  const handleClick = (e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation()

    if (collected) return

    setCollected(true)
    addStarToken(1)
    playSound('success')

    console.log(`StarToken collected! ID: ${props.id || 'N/A'}`)
  }

  // Hide heart once collected
  if (collected) return null

  return (
    <group {...props} ref={ref} dispose={null} onClick={handleClick}>
      <group name="Scene">
        <instances.Heart
          name="Heart"
          rotation={[0, 0, -Math.PI / 2]}
          userData={{ name: 'Heart', collectibleId: props.id }}
        >
            <meshStandardMaterial attach="material" color="hotpink" emissive="hotpink" emissiveIntensity={0.5} />
        </instances.Heart>
      </group>
    </group>
  )
}

useGLTF.preload('/geometries/heart.gltf')
